# Install Development Machine

Development machine will also be used as the bastion host to install the OpenShift cluster. It will also act as a local nameserver and the default gateway for the cluster.

As mentioned in the table above RHEL 9.1 will be used. But the content explained here should be valid for Fedora as well. Any other equivalent Linux distribution should provide the same functionality. The possible modification required because of the usage of a different Linux distribution will not be covered in this material. Content below starts with the state where Linux login is available. Below is the initial state of the development machine `trip-dev.tuff.local`:

```bash
# cat /proc/cpuinfo | grep processor
processor       : 0
processor       : 1
processor       : 2
processor       : 3

# free -m
               total        used        free      shared  buff/cache   available
Mem:            7661         581        7085           9         248        7079

# df -h
Filesystem      Size  Used Avail Use% Mounted on
devtmpfs        4.0M     0  4.0M   0% /dev
tmpfs           3.8G     0  3.8G   0% /dev/shm
tmpfs           1.5G  9.0M  1.5G   1% /run
/dev/nvme0n1p1 1000G  8.2G  992G   1% /
tmpfs           767M     0  767M   0% /run/user/0

[root@trip-dev ~]# cat /etc/redhat-release
Red Hat Enterprise Linux release 9.2 (Plow)

# hostname   
trip-dev.tuff.local

# ip -4 -c -br a
lo               UNKNOWN        127.0.0.1/8 
ens160           UP             192.168.1.140/24 
ens192           UP             10.10.221.254/24 

# ip -4 -c -br route
default via 192.168.1.1 dev ens160 proto static metric 100 
10.10.221.0/24 dev ens192 proto kernel scope link src 10.10.221.5 metric 101 
192.168.1.0/24 dev ens160 proto kernel scope link src 192.168.1.140 metric 100 

# # cat /etc/resolv.conf 
# Generated by NetworkManager
search tuff.local
nameserver 10.10.221.254

```

## 1. Install coredns

We will install coredns running as a container. We will also set up a systemd service to control the updates and the operations:

We will use directory To make the selection an inline code, use backticks around the text. Like this: `/opt/tuff/dns`. Create coredns files:

```bash
# mkdir -p /opt/tuff/dns/coredns
# mkdir -p /opt/tuff/dns/bin
# tee -a /opt/tuff/dns/coredns/Corefile <<EOF    
.:53 {
    log
    forward . 8.8.8.8
}
tuff.local:53 {
        log
        errors
        file /zones/tuff.local
}
EOF

# tee -a /opt/tuff/dns/coredns/tuff.local <<EOF    
$TTL    604800
@       IN      SOA  trip-dev.tuff.local. root.tuff.local. (
                        2023051001 ; serial
                        3600        ; refresh
                        600         ; retry
                        604800      ; expire
                        600         ; minimum
                        )

                  IN      NS      trip-dev.tuff.local.
trip-dev          IN      A       10.10.221.254
gw                IN      CNAME   trip-dev.tripko.local.

trip-ocp          IN      A       10.10.221.5
api.tripko        IN      CNAME   trip-ocp.tuff.local.
api-int.tripko    IN      CNAME   trip-ocp.tuff.local.
*.apps.tripko     IN      CNAME   trip-ocp.tuff.local.
EOF
```

Create `systemd` content:

```bash
# tee -a /opt/tuff/dns/bin/tuff-dns <<EOF    
#!/bin/bash
clear
CORE_DIR="/etc/coredns"
ZONE_DIR="/zones"
WORKDIR="/opt/tuff/dns/coredns"
TOKEN="coredns"
IMAGE="docker.io/coredns/coredns:latest"
IP=10.10.221.254

startTuffDNS () {
echo "Start Tuff DNS"
podman run -d --name $TOKEN \
-p $IP:53:53/udp -p $IP:53:53/tcp \
-v $WORKDIR/Corefile:$CORE_DIR/Corefile \
-v $WORKDIR/tuff.local:$ZONE_DIR/tuff.local \
$IMAGE -conf /etc/coredns/Corefile
}

stopTuffDNS () {
echo "Stop Tuff DNS"
podman stop coredns
podman rm coredns
}

checkTuffDNS () {
echo "OK!"
}

case "$1" in
        start)
                startTuffDNS
                ;;
        stop)
                stopTuffDNS
                ;;
        status)
                checkTuffDNS
                ;;
        restart)
                startTuffDNS
                stopTuffDNS
                ;;
        *)
            echo $"Usage: $0 {start|stop|restart|status}"
            exit 1
 
esac
EOF

# chmod +x /opt/tuff/dns/bin/tuff-dns

# tee -a /etc/systemd/system/tuffdns.service <<EOF    
[Unit]
Description=tuffDNS

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/opt/tuff/dns/bin/tuff-dns start
ExecStop=/opt/tuff/dns/bin/tuff-dns stop

[Install]
WantedBy=multi-user.target
EOF

# systemctl daemon-reload

# systemctl enable --now tuffdns

# podman ps
CONTAINER ID  IMAGE                             COMMAND               CREATED        STATUS        PORTS                                               NAMES
a25db46c3ec7  docker.io/coredns/coredns:latest  -conf /etc/coredn...  6 minutes ago  Up 6 minutes  10.10.221.254:53->53/tcp, 10.10.221.254:53->53/udp  coredn

# dig trip-ocp.tuff.local +short
10.10.221.5

# dig redhat.com +short         
52.200.142.250
34.235.198.240

# curl -I https://www.redhat.com/en         
HTTP/2 200 
server: Apache
x-ua-compatible: IE=edge
...
```

## 2. Install Gateway Services

Developer machine should have ip forwarding enabled and also NAT capability. We will add a second IP address (`192.168.1.141/24`) to the external interface and use it to separate OpenShift cluster traffic.

Enable `ip_forward`.:

```bash
# nmcli con mod ens160 ipv4.addresses "192.168.1.140/24,192.168.1.141/24"

# nmcli con down ens160; nmcli con up ens160

# ip -4 -c -br a
lo               UNKNOWN        127.0.0.1/8 
ens160           UP             192.168.1.140/24 192.168.1.141/24 
ens192           UP             10.10.221.254/24 
podman0          UP             10.88.0.1/16

# echo "ip_forward=1" > /etc/sysctl.conf
```

Make network configuration changes:

```bash
# mkdir -p /opt/tuff/network/bin

# tee /opt/tuff/network/bin/tuff-network <<EOF
#!/bin/bash

startTuffNetwork () {
echo "Start Tuff Network"
iptables -t nat -I POSTROUTING -s 10.10.221.5 -j SNAT --to-source 192.168.1.141
iptables -t nat -I PREROUTING -d 192.168.1.141 -j DNAT --to-destination 10.10.221.5
iptables -I INPUT -d 192.168.1.141 -j DROP
iptables -I INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

}

stopTuffNetwork () {
echo "Stop Tuff Network"
iptables -t nat -D POSTROUTING -s 10.10.221.5 -j SNAT --to-source 192.168.1.141
iptables -t nat -D PREROUTING -d 192.168.1.141 -j DNAT --to-destination 10.10.221.5
iptables -D INPUT -d 192.168.1.141 -j DROP
iptables -D INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
}

checkTuffNetwork () {
echo "OK!"
}

case "$1" in
        start)
                startTuffNetwork
                ;;
        stop)
                stopTuffNetwork
                ;;
        status)
                checkTuffNetwork
                ;;
        restart)
                startTuffNetwork
                stopTuffNetwork
                ;;
        *)
            echo $"Usage: $0 {start|stop|restart|status}"
            exit 1
 
esac
EOF

# chmod +x /opt/tuff/network/bin/tuff-network

# tee -a /etc/systemd/system/tuffnetwork.service <<EOF
[Unit]
Description=tuffnetwork

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/opt/tuff/network/bin/tuff-network start
ExecStop=/opt/tuff/network/bin/tuff-network stop

[Install]
WantedBy=multi-user.target
EOF

# systemctl daemon-reload     

# systemctl status tuffnetwork
○ tuffnetwork.service - tuffnetwork
     Loaded: loaded (/etc/systemd/system/tuffnetwork.service; disabled; preset: disabled)
     Active: inactive (dead)

# systemctl enable --now tuffnetwork 
Created symlink /etc/systemd/system/multi-user.target.wants/tuffnetwork.service → /etc/systemd/system/tuffnetwork.service.

# systemctl status tuffnetwork      
● tuffnetwork.service - tuffnetwork
     Loaded: loaded (/etc/systemd/system/tuffnetwork.service; enabled; preset: disabled)
     Active: active (exited) since Wed 2023-05-10 19:15:08 CEST; 2s ago
    Process: 1911 ExecStart=/opt/tuff/network/bin/tuff-network start (code=exited, status=0/SUCCESS)
   Main PID: 1911 (code=exited, status=0/SUCCESS)
        CPU: 11ms

May 10 19:15:07 trip-dev.tuff.local systemd[1]: Starting tuffnetwork...
May 10 19:15:07 trip-dev.tuff.local tuff-network[1911]: Start Tuff Network
May 10 19:15:08 trip-dev.tuff.local systemd[1]: Finished tuffnetwork.

# iptables -t nat -L -n | grep 10.10.221.5
DNAT       all  --  0.0.0.0/0            192.168.1.141        to:10.10.221.5
SNAT       all  --  10.10.221.5          0.0.0.0/0            to:192.168.1.141
```

At this stage everything should be working fine after a reboot.

## 3. Install Development  Tools

We will install [GO](https://go.dev/) and Git components. Following components are required as prerequisites:

- gcc
- make

We will create /home/workspace to hold our development projects.

```bash
# dnf install -y gcc make
# dnf install -y git
# mkdir /home/workspace
```

At this point add your SSH key to your [Github](https://github.com) account and complete your global git configuration at the developer machine. Install GO ([https://go.dev/doc/install](https://go.dev/doc/install)):

```bash
# wget https://go.dev/dl/go1.20.4.linux-amd64.tar.gz

# rm -rf /usr/local/go && tar -C /usr/local -xzf go1.20.4.linux-amd64.tar.gz

# export PATH=$PATH:/usr/local/go/bin

# go version
go version go1.20.4 linux/amd64
```

Test the git config and the ssh keys:

```bash
# git clone git@github.com:kursad-yildirim/trip-test.git
Cloning into 'trip-test'...
remote: Enumerating objects: 3, done.
remote: Counting objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Receiving objects: 100% (3/3), done.

# cd trip-test/

# echo "new test line " >>  README.md    

# git add .

# git commit -m "test commit"
[main 831b27e] test commit
 1 file changed, 1 insertion(+), 1 deletion(-)
[root@trip-dev trip-test]# git push
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Writing objects: 100% (3/3), 268 bytes | 268.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:kursad-yildirim/trip-test.git
   5f8d7a4..831b27e  main -> main
```

Finally lets test GO. We will use following simple code as `main.go`:

```go
package main

import (
        "fmt"
)

func main() {
        fmt.Println("GO World!")
}
```

Test run and build:

```bash
# go run main.go 
GO World!

# go build main.go 

# ./main 
GO World!
```

Development machine has been installed and ready to use.